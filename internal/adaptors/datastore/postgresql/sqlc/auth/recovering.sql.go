// Code generated by sqlc. DO NOT EDIT.
// source: recovering.sql

package auth_store

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createUserRecovery = `-- name: CreateUserRecovery :one
INSERT INTO recovering (user_id, recovery_link, expiry_date, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING user_id, recovery_link, expiry_date, created_at, updated_at
`

type CreateUserRecoveryParams struct {
	UserID       uuid.UUID `json:"userID"`
	RecoveryLink string    `json:"recoveryLink"`
	ExpiryDate   time.Time `json:"expiryDate"`
	CreatedAt    time.Time `json:"createdAt"`
	UpdatedAt    time.Time `json:"updatedAt"`
}

func (q *Queries) CreateUserRecovery(ctx context.Context, arg CreateUserRecoveryParams) (Recovering, error) {
	row := q.queryRow(ctx, q.createUserRecoveryStmt, createUserRecovery,
		arg.UserID,
		arg.RecoveryLink,
		arg.ExpiryDate,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Recovering
	err := row.Scan(
		&i.UserID,
		&i.RecoveryLink,
		&i.ExpiryDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUserRecoveryByID = `-- name: DeleteUserRecoveryByID :exec
DELETE
FROM recovering
WHERE user_id = $1
`

func (q *Queries) DeleteUserRecoveryByID(ctx context.Context, userID uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteUserRecoveryByIDStmt, deleteUserRecoveryByID, userID)
	return err
}

const deleteUserRecoveryByRecoveryLink = `-- name: DeleteUserRecoveryByRecoveryLink :exec
DELETE
FROM recovering
WHERE recovery_link = $1
`

func (q *Queries) DeleteUserRecoveryByRecoveryLink(ctx context.Context, recoveryLink string) error {
	_, err := q.exec(ctx, q.deleteUserRecoveryByRecoveryLinkStmt, deleteUserRecoveryByRecoveryLink, recoveryLink)
	return err
}

const getUserRecoveryByID = `-- name: GetUserRecoveryByID :one
SELECT user_id, recovery_link, expiry_date, created_at, updated_at
FROM recovering
WHERE user_id = $1
LIMIT 1
`

func (q *Queries) GetUserRecoveryByID(ctx context.Context, userID uuid.UUID) (Recovering, error) {
	row := q.queryRow(ctx, q.getUserRecoveryByIDStmt, getUserRecoveryByID, userID)
	var i Recovering
	err := row.Scan(
		&i.UserID,
		&i.RecoveryLink,
		&i.ExpiryDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserRecoveryByRecoveryLink = `-- name: GetUserRecoveryByRecoveryLink :one
SELECT user_id, recovery_link, expiry_date, created_at, updated_at
FROM recovering
WHERE recovery_link = $1
LIMIT 1
`

func (q *Queries) GetUserRecoveryByRecoveryLink(ctx context.Context, recoveryLink string) (Recovering, error) {
	row := q.queryRow(ctx, q.getUserRecoveryByRecoveryLinkStmt, getUserRecoveryByRecoveryLink, recoveryLink)
	var i Recovering
	err := row.Scan(
		&i.UserID,
		&i.RecoveryLink,
		&i.ExpiryDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserRecoveryByRecoveryLink = `-- name: UpdateUserRecoveryByRecoveryLink :one
UPDATE recovering
SET (expiry_date, updated_at) = ($2, $3)
WHERE recovery_link = $1
RETURNING user_id, recovery_link, expiry_date, created_at, updated_at
`

type UpdateUserRecoveryByRecoveryLinkParams struct {
	RecoveryLink string    `json:"recoveryLink"`
	ExpiryDate   time.Time `json:"expiryDate"`
	UpdatedAt    time.Time `json:"updatedAt"`
}

func (q *Queries) UpdateUserRecoveryByRecoveryLink(ctx context.Context, arg UpdateUserRecoveryByRecoveryLinkParams) (Recovering, error) {
	row := q.queryRow(ctx, q.updateUserRecoveryByRecoveryLinkStmt, updateUserRecoveryByRecoveryLink, arg.RecoveryLink, arg.ExpiryDate, arg.UpdatedAt)
	var i Recovering
	err := row.Scan(
		&i.UserID,
		&i.RecoveryLink,
		&i.ExpiryDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserRecoveryByUserID = `-- name: UpdateUserRecoveryByUserID :one
UPDATE recovering
SET (recovery_link, expiry_date, updated_at) = ($2, $3, $4)
WHERE user_id = $1
RETURNING user_id, recovery_link, expiry_date, created_at, updated_at
`

type UpdateUserRecoveryByUserIDParams struct {
	UserID       uuid.UUID `json:"userID"`
	RecoveryLink string    `json:"recoveryLink"`
	ExpiryDate   time.Time `json:"expiryDate"`
	UpdatedAt    time.Time `json:"updatedAt"`
}

func (q *Queries) UpdateUserRecoveryByUserID(ctx context.Context, arg UpdateUserRecoveryByUserIDParams) (Recovering, error) {
	row := q.queryRow(ctx, q.updateUserRecoveryByUserIDStmt, updateUserRecoveryByUserID,
		arg.UserID,
		arg.RecoveryLink,
		arg.ExpiryDate,
		arg.UpdatedAt,
	)
	var i Recovering
	err := row.Scan(
		&i.UserID,
		&i.RecoveryLink,
		&i.ExpiryDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
